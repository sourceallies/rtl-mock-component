import React, { Component, ReactHTML, RefCallback, useEffect, useRef } from "react";
import { FC } from "react";

type FunctionOrClassComponent<PropType> = FC<PropType> | (new (props: PropType) => Component<PropType>);

export type MockedComponent<PropType> = FunctionOrClassComponent<PropType> & {
    mockImplementation: (impl: FunctionOrClassComponent<PropType> | any) => void 
};

export type MockedElement<PropType = {}> = HTMLElement & {
    props: PropType, 
    component: MockedComponent<PropType>
};

export const mockElementTestId = 'rtl-mock-element';

function ensureIsMock<PropType>(mockedComponent: FunctionOrClassComponent<PropType>) {
    const mockImplementation = (mockedComponent as any).mockImplementation;
    if (typeof mockImplementation !== 'function') {
        throw new Error(`${mockedComponent.name} cannot be setup because it is not a compatable mock. Call "jest.mock('path/to/component')" or "vi.mock('path/to/component')" first`);
    }
    return mockedComponent as unknown as MockedComponent<PropType>;
}

export interface MockComponentOptions {
    /**
     * The react element generated by the mock. `div` by default.
     */
    element?: keyof ReactHTML;
}

function createMockComponent<PropType>(mockedComponent: MockedComponent<PropType>, options?: MockComponentOptions): FC<PropType> {
    const MockImplementation: FC<PropType> = (props) => {
        const mockedElmentRef = useRef<MockedElement<PropType> | null>(null);
        useEffect(() => {
            if (mockedElmentRef.current) {
                mockedElmentRef.current.props = props;
            }
        }, [props]);

        const ref: RefCallback<HTMLDivElement> = (el) => {
            mockedElmentRef.current = el as unknown as MockedElement<PropType>;
            if (mockedElmentRef.current) {
                mockedElmentRef.current.component = mockedComponent; //TODO: fix me
            }
        };

        const type: keyof ReactHTML = options?.element ?? 'div';
        return React.createElement(type, {
            ref,
            'data-testid': mockElementTestId,
        }, props.children);
    };
    return MockImplementation;
}

export function setupMockComponent<PropType>(maybeMockedComponent: FunctionOrClassComponent<PropType>, options?: MockComponentOptions) {
    const mockedComponent = ensureIsMock(maybeMockedComponent);
    const MockImplementation = createMockComponent(mockedComponent, options);
    if (isClassComponent(maybeMockedComponent)) {
        setupClassComponent(MockImplementation, mockedComponent);
    } else {
        mockedComponent.mockImplementation(MockImplementation);
    }
}

function setupClassComponent<PropType>(MockImplementation: FC<PropType>, mockedComponent: MockedComponent<PropType>) {
    class MockClassComponentWrapper extends Component<PropType> {
        render() {
            return <MockImplementation {...this.props} />;
        }
    }
    mockedComponent.mockImplementation((props: PropType) => new MockClassComponentWrapper(props));
}

function isClassComponent<PropType>(mockedComponent: FunctionOrClassComponent<PropType>) {
    return 'isReactComponent' in mockedComponent.prototype;
}
